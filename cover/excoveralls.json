{"source_files":[{"name":"lib/jirasaur.ex","source":"defmodule Jirasaur do\n  use Application\n\n  # See http://elixir-lang.org/docs/stable/elixir/Application.html\n  # for more information on OTP Applications\n  def start(_type, _args) do\n    import Supervisor.Spec\n\n    # Define workers and child supervisors to be supervised\n    children = [\n      # Start the Ecto repository\n      supervisor(Jirasaur.Repo, []),\n      # Start the endpoint when the application starts\n      supervisor(Jirasaur.Endpoint, []),\n      # Start your own worker by calling: Jirasaur.Worker.start_link(arg1, arg2, arg3)\n      # worker(Jirasaur.Worker, [arg1, arg2, arg3]),\n    ]\n\n    # See http://elixir-lang.org/docs/stable/elixir/Supervisor.html\n    # for other strategies and supported options\n    opts = [strategy: :one_for_one, name: Jirasaur.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n\n  # Tell Phoenix to update the endpoint configuration\n  # whenever the application is updated.\n  def config_change(changed, _new, removed) do\n    Jirasaur.Endpoint.config_change(changed, removed)\n    :ok\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,0,null,null,null]},{"name":"lib/jirasaur/endpoint.ex","source":"defmodule Jirasaur.Endpoint do\n  use Phoenix.Endpoint, otp_app: :jirasaur\n\n  socket \"/socket\", Jirasaur.UserSocket\n\n  # Serve at \"/\" the static files from \"priv/static\" directory.\n  #\n  # You should set gzip to true if you are running phoenix.digest\n  # when deploying your static files in production.\n  plug Plug.Static,\n    at: \"/\", from: :jirasaur, gzip: false,\n    only: ~w(css fonts images js favicon.ico robots.txt)\n\n  # Code reloading can be explicitly enabled under the\n  # :code_reloader configuration of your endpoint.\n  if code_reloading? do\n    socket \"/phoenix/live_reload/socket\", Phoenix.LiveReloader.Socket\n    plug Phoenix.LiveReloader\n    plug Phoenix.CodeReloader\n  end\n\n  plug Plug.RequestId\n  plug Plug.Logger\n\n  plug Plug.Parsers,\n    parsers: [:urlencoded, :multipart, :json],\n    pass: [\"*/*\"],\n    json_decoder: Poison\n\n  plug Plug.MethodOverride\n  plug Plug.Head\n\n  # The session will be stored in the cookie and signed,\n  # this means its contents can be read but not tampered with.\n  # Set :encryption_salt if you would also like to encrypt it.\n  plug Plug.Session,\n    store: :cookie,\n    key: \"_jirasaur_key\",\n    signing_salt: \"AVB9Vhr5\"\n\n  plug Jirasaur.Router\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/jirasaur/repo.ex","source":"defmodule Jirasaur.Repo do\n  use Ecto.Repo, otp_app: :jirasaur\nend","coverage":[null,null,null]},{"name":"test/support/channel_case.ex","source":"defmodule Jirasaur.ChannelCase do\n  @moduledoc \"\"\"\n  This module defines the test case to be used by\n  channel tests.\n\n  Such tests rely on `Phoenix.ChannelTest` and also\n  import other functionality to make it easier\n  to build and query models.\n\n  Finally, if the test case interacts with the database,\n  it cannot be async. For this reason, every test runs\n  inside a transaction which is reset at the beginning\n  of the test unless the test case is marked as async.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      # Import conveniences for testing with channels\n      use Phoenix.ChannelTest\n\n      alias Jirasaur.Repo\n      import Ecto\n      import Ecto.Changeset\n      import Ecto.Query\n\n\n      # The default endpoint for testing\n      @endpoint Jirasaur.Endpoint\n    end\n  end\n\n  setup tags do\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Jirasaur.Repo)\n\n    unless tags[:async] do\n      Ecto.Adapters.SQL.Sandbox.mode(Jirasaur.Repo, {:shared, self()})\n    end\n\n    :ok\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,null,null,null,null]},{"name":"test/support/conn_case.ex","source":"defmodule Jirasaur.ConnCase do\n  @moduledoc \"\"\"\n  This module defines the test case to be used by\n  tests that require setting up a connection.\n\n  Such tests rely on `Phoenix.ConnTest` and also\n  import other functionality to make it easier\n  to build and query models.\n\n  Finally, if the test case interacts with the database,\n  it cannot be async. For this reason, every test runs\n  inside a transaction which is reset at the beginning\n  of the test unless the test case is marked as async.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      # Import conveniences for testing with connections\n      use Phoenix.ConnTest\n\n      alias Jirasaur.Repo\n      import Ecto\n      import Ecto.Changeset\n      import Ecto.Query\n\n      import Jirasaur.Router.Helpers\n\n      # The default endpoint for testing\n      @endpoint Jirasaur.Endpoint\n    end\n  end\n\n  setup tags do\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Jirasaur.Repo)\n\n    unless tags[:async] do\n      Ecto.Adapters.SQL.Sandbox.mode(Jirasaur.Repo, {:shared, self()})\n    end\n\n    {:ok, conn: Phoenix.ConnTest.build_conn()}\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,25,null,25,22,null,null,null,null,null]},{"name":"test/support/fixtures.ex","source":"defmodule Jirasaur.Fixtures do\n  alias Jirasaur.User\n  alias Jirasaur.Task\n  alias Jirasaur.TaskStatus\n  alias Jirasaur.TaskType\n  alias Jirasaur.UserTask\n\n  def fixture(type, assoc \\\\ [])\n\n  def fixture(:user, assoc) do\n    team_domain = assoc[:team_domain] || \"XY1\"\n    team_id = assoc[:team_id] || \"radev\"\n    user_id = assoc[:user_id] || \"RS0\"\n    user_name = assoc[:user_name] || \"Radek\"\n    attrs =  %{team_domain: team_domain, team_id: team_id, user_id: user_id, user_name: user_name}\n    changeset = User.changeset(%User{}, attrs)\n    case Jirasaur.Repo.insert(changeset) do\n      {:ok, inserted_user} ->\n          user = inserted_user\n       end\n  end\n  def fixture(:task, assoc) do\n    task_status = assoc[:task_status] || fixture(:task_status)\n    task_type = assoc[:task_type] || fixture(:task_type)\n    task_name = assoc[:task_name] || \"JIRA-XXX\"\n    attrs =  %{name: task_name,task_status_id: task_status.id, task_type_id: task_type.id}\n    changeset = Task.changeset(%Task{}, attrs)\n    case Jirasaur.Repo.insert(changeset) do\n      {:ok, inserted_task} ->\n          task = inserted_task\n    end\n  end\n\n  def fixture(:user_task, assoc) do\n    task = assoc[:task] || fixture(:task)\n    user = assoc[:user] || fixture(:user)\n    user_task_started = assoc[:started] || DateTime.utc_now\n    user_task_finished = assoc[:finished] || \"\"\n    attrs =  %{started: user_task_started,finished: user_task_finished,task_id: task.id, user_id: user.id}\n    changeset = UserTask.changeset(%UserTask{}, attrs)\n    case Jirasaur.Repo.insert(changeset) do\n      {:ok, inserted_user_task} ->\n          user_task = inserted_user_task\n    end\n  end\n\n  def fixture(:task_type, assoc) do\n    name = assoc[:task_type_name] || \"task\"\n    attrs =  %{name: name}\n    changeset = TaskType.changeset(%TaskType{}, attrs)\n    case Jirasaur.Repo.insert(changeset) do\n      {:ok, inserted_task_type} ->\n          task_type = inserted_task_type\n       end\n  end\n\n    def fixture(:task_status, assoc) do\n    name = assoc[:task_status_name] || \"done\"\n    attrs =  %{name: name}\n    changeset = TaskStatus.changeset(%TaskStatus{}, attrs)\n    case Jirasaur.Repo.insert(changeset) do\n      {:ok, inserted_task_status} ->\n          task_type = inserted_task_status\n    end\n  end\n\n\nend","coverage":[null,null,null,null,null,null,null,58,null,null,14,14,14,14,14,14,14,null,14,null,null,null,17,17,17,17,17,17,null,17,null,null,null,null,11,11,11,11,11,11,11,null,11,null,null,null,null,17,17,17,17,null,17,null,null,null,null,16,16,16,16,null,16,null,null,null,null,null]},{"name":"test/support/model_case.ex","source":"defmodule Jirasaur.ModelCase do\n  @moduledoc \"\"\"\n  This module defines the test case to be used by\n  model tests.\n\n  You may define functions here to be used as helpers in\n  your model tests. See `errors_on/2`'s definition as reference.\n\n  Finally, if the test case interacts with the database,\n  it cannot be async. For this reason, every test runs\n  inside a transaction which is reset at the beginning\n  of the test unless the test case is marked as async.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      alias Jirasaur.Repo\n\n      import Ecto\n      import Ecto.Changeset\n      import Ecto.Query\n      import Jirasaur.ModelCase\n    end\n  end\n\n  setup tags do\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Jirasaur.Repo)\n\n    unless tags[:async] do\n      Ecto.Adapters.SQL.Sandbox.mode(Jirasaur.Repo, {:shared, self()})\n    end\n\n    :ok\n  end\n\n  @doc \"\"\"\n  Helper for returning list of errors in a struct when given certain data.\n\n  ## Examples\n\n  Given a User schema that lists `:name` as a required field and validates\n  `:password` to be safe, it would return:\n\n      iex> errors_on(%User{}, %{password: \"password\"})\n      [password: \"is unsafe\", name: \"is blank\"]\n\n  You could then write your assertion like:\n\n      assert {:password, \"is unsafe\"} in errors_on(%User{}, %{password: \"password\"})\n\n  You can also create the changeset manually and retrieve the errors\n  field directly:\n\n      iex> changeset = User.changeset(%User{}, password: \"password\")\n      iex> {:password, \"is unsafe\"} in changeset.errors\n      true\n  \"\"\"\n  def errors_on(struct, data) do\n    struct.__struct__.changeset(struct, data)\n    |> Ecto.Changeset.traverse_errors(&Jirasaur.ErrorHelpers.translate_error/1)\n    |> Enum.flat_map(fn {key, errors} -> for msg <- errors, do: {key, msg} end)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,null,null,null,null,null,null,null,null,null,null,40,null,40,40,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null]},{"name":"web/channels/user_socket.ex","source":"defmodule Jirasaur.UserSocket do\n  use Phoenix.Socket\n\n  ## Channels\n  # channel \"room:*\", Jirasaur.RoomChannel\n\n  ## Transports\n  transport :websocket, Phoenix.Transports.WebSocket\n  # transport :longpoll, Phoenix.Transports.LongPoll\n\n  # Socket params are passed from the client and can\n  # be used to verify and authenticate a user. After\n  # verification, you can put default assigns into\n  # the socket that will be set for all channels, ie\n  #\n  #     {:ok, assign(socket, :user_id, verified_user_id)}\n  #\n  # To deny connection, return `:error`.\n  #\n  # See `Phoenix.Token` documentation for examples in\n  # performing token verification on connect.\n  def connect(_params, socket) do\n    {:ok, socket}\n  end\n\n  # Socket id's are topics that allow you to identify all sockets for a given user:\n  #\n  #     def id(socket), do: \"users_socket:#{socket.assigns.user_id}\"\n  #\n  # Would allow you to broadcast a \"disconnect\" event and terminate\n  # all active sockets and channels for a given user:\n  #\n  #     Jirasaur.Endpoint.broadcast(\"users_socket:#{user.id}\", \"disconnect\", %{})\n  #\n  # Returning `nil` makes this socket anonymous.\n  def id(_socket), do: nil\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"web/controllers/api/v1/report_controller.ex","source":"defmodule Jirasaur.Api.V1.ReportController do\n\trequire Logger\n  use Jirasaur.Web, :controller\n  import Jirasaur.ErrorsHelper\n  alias Jirasaur.User\n  plug :setup_user\n  plug :setup_task\n  \n  def process_request(conn, _params) do\n  \t\tuser = conn.assigns[:user]\n      task = conn.assigns[:task]\n      #cmd = conn.assigns[:cmd]\n\t\t  #json conn, \"#{user.user_name}:#{cmd}\"\n      json conn, \"user: #{user.user_name},\n                  task: #{task.name},\n                  task type: #{task.task_type.name}\"\n  end\n\n  defp setup_task(conn, params) do\n    if(conn.params[\"text\"] == nil) do\n      show_bad_req(conn)\n    else\n      Jirasaur.ReportHelper.process_cmd(conn, params)\n    end\n  end\n\n  defp setup_user(conn, _params) do\n  \t\n    if(conn.params[\"user_id\"] != nil) do\n      user_id = String.downcase(conn.params[\"user_id\"])\n    \tuser = Jirasaur.Repo.get_by(Jirasaur.User, user_id: user_id)\n    \tif (user == nil) do\n    \t changeset = User.changeset(%User{}, conn.params)\n    \t case Jirasaur.Repo.insert(changeset) do\n        {:ok, inserted_user} ->\n          user = inserted_user\n          assign(conn, :user, user) \n        {:error, _changeset} ->\n          show_bad_req(conn)\n       end\n   \t  else \n   \t   assign(conn, :user, user)\n    \tend\n    else\n      show_bad_req(conn)\n    end\n  end\n\n\n  \n #TO-DO case insesitivity, user creation\nend","coverage":[null,null,null,null,null,null,null,null,null,17,17,null,null,17,17,17,null,null,null,20,0,null,20,null,null,null,null,null,21,20,20,20,16,16,null,16,16,null,0,null,null,4,null,null,1,null,null,null,null,null,null,null]},{"name":"web/controllers/page_controller.ex","source":"defmodule Jirasaur.PageController do\n  use Jirasaur.Web, :controller\n\n  def index(conn, _params) do\n    render conn, \"index.html\"\n  end\nend","coverage":[null,null,null,null,1,null,null]},{"name":"web/controllers/user_controller.ex","source":"defmodule Jirasaur.UserController do\n  use Jirasaur.Web, :controller\n\n  alias Jirasaur.User\n\n  def index(conn, _params) do\n    users = Repo.all(User)\n    render(conn, \"index.html\", users: users)\n  end\n\n  def new(conn, _params) do\n    changeset = User.changeset(%User{})\n    render(conn, \"new.html\", changeset: changeset)\n  end\n\n  def create(conn, %{\"user\" => user_params}) do\n    changeset = User.changeset(%User{}, user_params)\n\n    case Repo.insert(changeset) do\n      {:ok, _user} ->\n       conn\n       |> put_status(:unauthorized)\n       |> render(Jirasaur.ErrorView, \"error.json\", code: :unauthorized)\n       |> halt()\n      {:error, changeset} ->\n        render(conn, \"new.html\", changeset: changeset)\n    end\n  end\n\n  def show(conn, %{\"id\" => id}) do\n    user = Repo.get!(User, id)\n    render(conn, \"show.html\", user: user)\n  end\n\n  def edit(conn, %{\"id\" => id}) do\n    user = Repo.get!(User, id)\n    changeset = User.changeset(user)\n    render(conn, \"edit.html\", user: user, changeset: changeset)\n  end\n\n  def update(conn, %{\"id\" => id, \"user\" => user_params}) do\n    user = Repo.get!(User, id)\n    changeset = User.changeset(user, user_params)\n\n    case Repo.update(changeset) do\n      {:ok, user} ->\n        conn\n        |> put_flash(:info, \"User updated successfully.\")\n        |> redirect(to: user_path(conn, :show, user))\n      {:error, changeset} ->\n        render(conn, \"edit.html\", user: user, changeset: changeset)\n    end\n  end\n\n  def delete(conn, %{\"id\" => id}) do\n    user = Repo.get!(User, id)\n\n    # Here we use delete! (with a bang) because we expect\n    # it to always work (and if it does not, it will raise).\n    Repo.delete!(user)\n\n    conn\n    |> put_flash(:info, \"User deleted successfully.\")\n    |> redirect(to: user_path(conn, :index))\n  end\nend","coverage":[null,null,null,null,null,null,0,0,null,null,null,0,0,null,null,null,0,null,0,null,null,null,null,0,null,0,null,null,null,null,0,0,null,null,null,0,0,0,null,null,null,0,0,null,0,null,null,null,0,null,0,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null]},{"name":"web/gettext.ex","source":"defmodule Jirasaur.Gettext do\n  @moduledoc \"\"\"\n  A module providing Internationalization with a gettext-based API.\n\n  By using [Gettext](https://hexdocs.pm/gettext),\n  your module gains a set of macros for translations, for example:\n\n      import Jirasaur.Gettext\n\n      # Simple translation\n      gettext \"Here is the string to translate\"\n\n      # Plural translation\n      ngettext \"Here is the string to translate\",\n               \"Here are the strings to translate\",\n               3\n\n      # Domain-based translation\n      dgettext \"errors\", \"Here is the error message to translate\"\n\n  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.\n  \"\"\"\n  use Gettext, otp_app: :jirasaur\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"web/helpers/errors_helper.ex","source":"defmodule Jirasaur.ErrorsHelper do\n  \n  def show_bad_req(conn,assoc \\\\ []) do\n  msg = assoc[:msg] || :bad_request\n   conn\n   |> Plug.Conn.put_status(:bad_request)\n   |> Phoenix.Controller.render(Jirasaur.ErrorView, \"error.json\", code: msg)\n   |> Plug.Conn.halt()\n  end\n\nend","coverage":[null,null,null,4,null,null,null,4,null,null,null]},{"name":"web/helpers/report_helper.ex","source":"defmodule Jirasaur.ReportHelper do\n\timport Jirasaur.ErrorsHelper\n\timport Ecto.Query, only: [from: 2]\n\tuse Timex\n\talias Jirasaur.Task\n\talias Jirasaur.TaskStatus\n\talias Jirasaur.TaskType\n\talias Jirasaur.UserTask\n\talias Jirasaur.Repo\n\t\n\tdef send(conn) do\n\t\tconn\n\tend\n\n\tdef process_cmd(conn, _opts) do\n\t\tcmd = String.split(conn.params[\"text\"])\n\t\tcmd_length = Kernel.length(cmd)\n\n\n\t\tcond do\n\t\t\tcmd_length == 1 ->\n\t\t \t process_task(\n\t\t \t \tconn,\n\t\t \t \ttask_name: Enum.at(cmd, 0)\n\t\t \t \t)\n\t\t\tcmd_length == 2 ->\n\t\t\t process_task(\n\t\t\t \tconn,\n\t\t\t \ttask_name: Enum.at(cmd, 0), \n\t\t\t \tstarted: Enum.at(cmd,1)\n\t\t\t \t)\n\t\t\tcmd_length == 3 ->\n\t\t\t \tprocess_task(\n\t\t\t \tconn, \n\t\t\t \ttask_name: Enum.at(cmd, 0), \n\t\t\t \tstarted: Enum.at(cmd,1),\n\t\t\t \tfinished: Enum.at(cmd,2),\n\t\t\t \t)\n\t\t\ttrue ->\n\t\t\t show_bad_req(conn)\n\t\tend\n\tend\n\n\tdefp process_task(conn,assoc \\\\ []) do\n\t\tuser = conn.assigns[:user]\n\t\ttask_name = String.downcase(assoc[:task_name])\n\t\tif(assoc[:started] != nil) do\n\t\t   task_started = convertTimeToDateTime(assoc[:started])\n\t\t   current_task_finished = convertTimeToDateTime(assoc[:started])\n\t\tend\n\n\t\tif(task_started == nil) do\n\t\t  task_started = Timex.now\n\t\t  current_task_finished = Timex.now\n\t\tend\n\t\tif(assoc[:finished] != nil) do\n\t\t   task_finished = convertTimeToDateTime(assoc[:finished])\n\t\tend\n\n\t\tif(task_finished == nil) do\n\t\t  task_finished = \"\"\n\t\tend\n\t\t\n\t\tif(task_name == nil) do\n\t\t\tshow_bad_req(conn)\n\t\tend\n\t\ttask = get_task(conn,task_name)\n\t\ttask = Task.preload(task.id)\n\t\tconn = Plug.Conn.assign(conn, :task, task)\n\n\t\tmost_recent = get_current_user_task(user.id)\n\t\tcond do\n\t\t\ttask.name == \"off\" and most_recent == nil  ->\n\t\t\t\tshow_bad_req(conn, msg: \"you have no reports today\")\n\t\t\ttask.name == \"morning\" and most_recent != nil ->\n\t\t\t\tshow_bad_req(conn, msg: \"already signed in\")\n\t\t\ttrue ->\n\t\t\t\tif(most_recent != nil) do\n\t\t\t\t\tupdate_current_task(conn,most_recent, current_task_finished)\t\n\t\t\t\tend\n\n\t\t\t\tif(task.name != \"off\") do \n\t\t\t\t\tnew_user_task = insert_user_task(conn, task.id, user.id, task_started, task_finished)\n\t\t\t\t\tconn = Plug.Conn.assign(conn, :user_task, new_user_task)\n\t\t\t\tend\n\t\t\t\tsend(conn)\n\t\tend\n\tend\n\n\tdefp convertTimeToDateTime(time) do\n\t\t[hour, minute] = String.split time, \":\"\n\t\thourInteger = Integer.parse(hour)\n\t\tminuteInteger = Integer.parse(minute)\n\t\ttoday = Timex.now\n\t\tdateTime = %DateTime{year: today.year, month: today.month, day: today.day, hour: elem(hourInteger,0), minute: elem(minuteInteger,0), second: 0, zone_abbr: \"UTC\", time_zone: \"Europe/London\", utc_offset: 0, std_offset: 0}\n\n\tend\n\n\tdefp update_current_task(conn,user_task, finished) do\n\t\tparams = %{task_id: user_task.task_id, \n\t\t\t\t   user_id: user_task.user_id,\n\t\t\t\t   started: user_task.started,\n\t\t\t\t   finished: finished}\n\t\tchangeset = UserTask.changeset(user_task, params)\n\n  \t\tcase Repo.update(changeset) do\n  \t\t {:ok, inserted_user_task} ->\n\t\t\tinserted_user_task\t\n    \t {:error, changeset} ->\n      \t\tshow_bad_req(conn)\n  end\n\t\t\n\tend\n\n\tdefp insert_user_task(conn, task_id, user_id,started, finished) do\n\t\tchangeset = UserTask.changeset(%UserTask{},%{task_id: task_id,\n\t\t\t\t\tuser_id: user_id,\n\t\t\t\t\tstarted: started,\n\t\t\t\t\tfinished: finished,\n\t\t\t\t\t})\n\t\tcase Jirasaur.Repo.insert(changeset) do\n\t\t\t{:ok, inserted_task} ->\n\t\t\t\tinserted_task\n\t\t\t{:error, _inserted_task_type} ->\n\t\t\t\tshow_bad_req(conn)\n\t\tend\n\tend\n\n\n\tdef get_current_user_task(user_id) do\n\t\tdate = Timex.now\n\t\tquery = Ecto.Query.from(t in UserTask,\n\t\t where: t.started >= ^Timex.beginning_of_day(date),\n\t\t where: t.user_id == ^user_id,\n  \t\t order_by: [desc: t.started],\n  \t\t limit: 1)\n\t\tmost_recent = Repo.one(query)\n\tend\n\n\tdefp get_task(conn,task_name) do\n\t\tJirasaur.Repo.get_by(Task, name: task_name) ||\n\t\t\t\tinsert_task(conn,task_name)\n\tend\n\n\tdefp insert_task(conn, task_name) do\n\t\ttask_type_name = get_task_type(task_name)\n\t\ttask_type = Jirasaur.Repo.get_by(TaskType, name: task_type_name) || \n\t\t\t\t\tinsert_new_task_type(conn,task_type_name)\n\t\ttask_status = get_task_status(conn)\n\t\tchangeset = Task.changeset(%Task{},%{name: task_name,\n\t\t\t\t\ttask_type_id: task_type.id,\n\t\t\t\t\ttask_status_id: task_status.id\n\t\t\t\t\t})\n\t\tcase Jirasaur.Repo.insert(changeset) do\n\t\t\t{:ok, inserted_task} ->\n\t\t\t\tinserted_task\n\t\t\t{:error, _inserted_task_type} ->\n\t\t\t\tshow_bad_req(conn)\n\t\tend\n\tend\n\n\tdefp get_task_type(task_name) do \n\t\ttask_type_name = cond do\n\t\t\ttask_name == \"private\" ->\n\t\t\t \"private\" \n\t\t\ttask_name == \"lunch\" ->\n\t\t\t \"private\"\n\t\t\tRegex.match?((~r/[A-Za-z0-9]*[-][0-9]*/),task_name) ->\n\t\t\t  \"task\"\n\t\t\ttask_name == \"meeting\" ->\n\t\t\t  \"meeting\"\n\t\t\t task_name == \"standup\" ->\n\t\t\t  \"meeting\"\t\n\t\t\ttrue ->\n\t\t\t  \"support\"\n\t\tend\n\tend\n\n\tdefp insert_new_task_type(conn,task_type_name) do\n\t\tchangeset = TaskType.changeset(%TaskType{},%{name: task_type_name})\n\t\tcase Jirasaur.Repo.insert(changeset) do\n\t\t\t{:ok, inserted_task_type} ->\n\t\t\t\tinserted_task_type\n\t\t\t{:error, _inserted_task_type} ->\n\t\t\t\tshow_bad_req(conn)\n\t\tend\n\n\tend\n\n\tdefp get_task_status(conn) do \n\t\ttask_status_name = \"in progress\"\n\t\tJirasaur.Repo.get_by(TaskStatus, name: task_status_name) || \n\t\t\t\t\tinsert_new_task_status(conn,task_status_name)\n\tend\n\n\tdefp insert_new_task_status(conn,task_status_name) do\n\t\tchangeset = TaskStatus.changeset(%TaskStatus{},%{name: task_status_name})\n\t\tcase Jirasaur.Repo.insert(changeset) do\n\t\t\t{:ok, inserted_task_status} ->\n\t\t\t\tinserted_task_status\n\t\t\t{:error, _inserted_task_type} ->\n\t\t\t\tshow_bad_req(conn)\n\t\tend\n\n\tend\n\n\n\n\n\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,17,null,null,null,20,20,null,null,20,null,17,null,null,null,3,1,null,null,null,null,2,1,null,null,null,null,null,null,1,null,null,null,null,19,19,19,2,2,null,null,19,17,17,null,19,1,null,null,19,18,null,null,19,0,null,19,19,19,null,19,19,19,1,18,1,null,17,3,null,null,17,16,16,null,17,null,null,null,null,5,5,5,5,5,null,null,null,null,3,3,3,null,3,null,3,null,3,null,0,null,null,null,null,null,16,null,null,null,null,16,null,16,null,0,null,null,null,null,null,21,21,null,null,null,null,21,null,null,null,19,15,null,null,null,15,15,13,15,15,15,15,null,15,null,15,null,0,null,null,null,null,15,null,null,14,null,14,null,10,null,9,null,null,null,null,null,null,null,13,13,null,13,null,0,null,null,null,null,null,15,15,14,null,null,null,14,14,null,14,null,0,null,null,null,null,null,null,null,null,null]},{"name":"web/models/task.ex","source":"defmodule Jirasaur.Task do\n  use Jirasaur.Web, :model\n  import Ecto.Query\n  schema \"tasks\" do\n    field :name, :string\n    belongs_to :task_type, Jirasaur.TaskType\n    belongs_to :task_status, Jirasaur.TaskStatus\n    has_many :user_tasks, Jirasaur.UserTask\n    many_to_many :users, Jirasaur.User, join_through: Jirasaur.UserTask\n    timestamps()\n  end\n\n  def preload(id) do\n    task = Jirasaur.Task |> Jirasaur.Repo.get(id) |> Jirasaur.Repo.preload([:users])|> Jirasaur.Repo.preload([:task_type]) |> Jirasaur.Repo.preload([:task_status]) |> Jirasaur.Repo.preload([:user_tasks])\n  end\n  @doc \"\"\"\n  Builds a changeset based on the `struct` and `params`.\n  \"\"\"\n  def changeset(struct, params \\\\ %{}) do\n    #IO.puts(\"#{params}\")\n    struct\n    |> cast(params, [:name,:task_type_id,:task_status_id])\n    |> put_assoc(:users, parse_users_ids(params))\n    |> downcase_value\n    |> validate_required([:name,:task_type_id,:task_status_id])\n    |> unique_constraint(:name)\n    |> foreign_key_constraint(:task_type_id)\n    |> foreign_key_constraint(:task_status_id)\n  end\n\n\n  def downcase_value(changeset) do\n      \n      update_change(changeset, :name, &String.downcase/1)\n  end\n\n  defp parse_users_ids(params) do\n    (params[\"users_ids\"] || [])\n    |> Enum.map(&get_users/1)\n  end\n\n  defp get_users(id) do\n    IO.puts(\"---2\")\n      Jirasaur.Repo.get_by(Jirasaur.User, id: id)\n  end\nend","coverage":[null,null,null,23,null,null,null,null,null,null,null,null,null,23,null,null,null,null,null,null,null,null,null,null,null,null,null,38,null,null,null,null,null,38,null,null,null,0,38,null,null,null,0,0,null,null]},{"name":"web/models/task_status.ex","source":"defmodule Jirasaur.TaskStatus do\n  use Jirasaur.Web, :model\n\n  schema \"taskstatuses\" do\n    field :name, :string\n    has_many :tasks, Jirasaur.Task\n    timestamps()\n  end\n\n  def preload(id) do\n    user = Jirasaur.TaskStatus |> Jirasaur.Repo.get(id)|> Jirasaur.Repo.preload([:tasks])\n  end\n  @doc \"\"\"\n  Builds a changeset based on the `struct` and `params`.\n  \"\"\"\n  def changeset(struct, params \\\\ %{}) do\n    struct\n    |> cast(params, [:name])\n    |> downcase_value\n    |> validate_required([:name])\n    |> unique_constraint(:name)\n  end\n\n  def downcase_value(changeset) do\n      update_change(changeset, :name, &String.downcase/1)\n  end\nend","coverage":[null,null,null,7,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,37,null,null,null,37,null,null]},{"name":"web/models/task_type.ex","source":"defmodule Jirasaur.TaskType do\n  use Jirasaur.Web, :model\n\n  schema \"tasktypes\" do\n    field :name, :string\n    has_many :tasks, Jirasaur.Task\n    timestamps()\n  end\n\n  def preload(id) do\n    user = Jirasaur.TaskType |> Jirasaur.Repo.get(id)|> Jirasaur.Repo.preload([:tasks])\n  end\n  @doc \"\"\"\n  Builds a changeset based on the `struct` and `params`.\n  \"\"\"\n  def changeset(struct, params \\\\ %{}) do\n    struct\n    |> cast(params, [:name])\n    |> downcase_value\n    |> validate_required([:name])\n    |> unique_constraint(:name)\n  end\n\n  def downcase_value(changeset) do\n      update_change(changeset, :name, &String.downcase/1)\n  end\nend","coverage":[null,null,null,27,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,37,null,null,null,37,null,null]},{"name":"web/models/user.ex","source":"defmodule Jirasaur.User do\n  use Jirasaur.Web, :model\n\n  schema \"users\" do\n    field :user_id, :string\n    field :user_name, :string\n    field :team_id, :string\n    field :team_domain, :string\n    has_many :user_tasks, Jirasaur.UserTask\n    many_to_many :tasks, Jirasaur.Task, join_through: Jirasaur.UserTask\n    timestamps()\n  end\n\n  def preload(id) do\n    user = Jirasaur.User |> Jirasaur.Repo.get(id)|> Jirasaur.Repo.preload([:tasks]) |> Jirasaur.Repo.preload([:user_tasks])\n  end\n\n  @doc \"\"\"\n  Builds a changeset based on the `struct` and `params`.\n  \"\"\"\n  def changeset(struct, params \\\\ %{}) do\n    struct\n    |> cast(params, [:user_id, :user_name, :team_id, :team_domain])\n    |> downcase_value\n    |> validate_required([:user_id, :user_name, :team_id, :team_domain])\n    |> unique_constraint(:user_id)\n  end\n\n  def downcase_value(changeset) do\n      update_change(changeset, :user_id, &String.downcase/1)\n  end\nend","coverage":[null,null,null,78,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,47,null,null,null,47,null,null]},{"name":"web/models/user_task.ex","source":"defmodule Jirasaur.UserTask do\n  use Jirasaur.Web, :model\n\n  schema \"usertasks\" do\n    field :started, Timex.Ecto.DateTime\n    field :finished, Timex.Ecto.DateTime\n    belongs_to :task, Jirasaur.Task\n    belongs_to :user, Jirasaur.User\n    timestamps()\n  end\n\n  def preload(id) do\n    user_task = Jirasaur.UserTask |> Jirasaur.Repo.get(id)|> Jirasaur.Repo.preload([:task]) |> Jirasaur.Repo.preload([:user])\n  end\n  @doc \"\"\"\n  Builds a changeset based on the `struct` and `params`.\n  \"\"\"\n  def changeset(struct, params \\\\ %{}) do\n    struct\n    |> cast(params, [:started, :finished,:task_id,:user_id])\n    |> validate_required([:started,:task_id,:user_id])\n    |> foreign_key_constraint(:task_id)\n    |> foreign_key_constraint(:user_id)\n  end\nend","coverage":[null,null,null,45,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,45,null,null]},{"name":"web/plug/authenticate_plug.ex","source":"defmodule Jirasaur.Plug.Authenticate do\n  @behaviour Plug\n  import Plug.Conn\n  import Phoenix.Controller, only: [render: 4]\n\n  def init(opts), do: opts\n\n  def call(conn, _opts) do\n    slack_token = System.get_env(\"SLACK_TOKEN\")\n    if (slack_token ==nil || slack_token != conn.params[\"token\"]) do  \n      conn\n      |> put_status(:unauthorized)\n      |> render(Jirasaur.ErrorView, \"error.json\", code: :unauthorized)\n      |> halt()\n    else\n      conn\n    end\n  end\nend","coverage":[null,null,null,null,null,0,null,null,22,22,null,null,null,1,null,21,null,null,null]},{"name":"web/router.ex","source":"defmodule Jirasaur.Router do\n  use Jirasaur.Web, :router\n\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_flash\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n  end\n\n  pipeline :api do\n    plug :accepts, [\"json\"]\n  end\n\n  pipeline :authenticated do\n    plug Jirasaur.Plug.Authenticate\n  end\n\n  scope \"/\", Jirasaur do\n    pipe_through :browser # Use the default browser stack\n\n    get \"/\", PageController, :index\n  end\n\n  scope \"/\", Jirasaur do\n    pipe_through [:browser,:authenticated]\n    resources \"/users\", UserController\n  end\n\n  scope \"/api\", Jirasaur.Api, as: :api do\n    pipe_through [:api,:authenticated]\n    scope \"/v1\", V1, as: :v1 do\n      post \"/report\", ReportController, :process_request\n    end\n  end\n\n\n\n  # Other scopes may use custom stacks.\n  # scope \"/api\", Jirasaur do\n  #   pipe_through :api\n  # end\nend","coverage":[null,null,null,1,null,null,null,null,null,null,null,22,null,null,null,22,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"web/views/error_helpers.ex","source":"defmodule Jirasaur.ErrorHelpers do\n  @moduledoc \"\"\"\n  Conveniences for translating and building error messages.\n  \"\"\"\n\n  use Phoenix.HTML\n\n  @doc \"\"\"\n  Generates tag for inlined form input errors.\n  \"\"\"\n  def error_tag(form, field) do\n    if error = form.errors[field] do\n      content_tag :span, translate_error(error), class: \"help-block\"\n    end\n  end\n\n  @doc \"\"\"\n  Translates an error message using gettext.\n  \"\"\"\n  def translate_error({msg, opts}) do\n    # Because error messages were defined within Ecto, we must\n    # call the Gettext module passing our Gettext backend. We\n    # also use the \"errors\" domain as translations are placed\n    # in the errors.po file.\n    # Ecto will pass the :count keyword if the error message is\n    # meant to be pluralized.\n    # On your own code and templates, depending on whether you\n    # need the message to be pluralized or not, this could be\n    # written simply as:\n    #\n    #     dngettext \"errors\", \"1 file\", \"%{count} files\", count\n    #     dgettext \"errors\", \"is invalid\"\n    #\n    if count = opts[:count] do\n      Gettext.dngettext(Jirasaur.Gettext, \"errors\", msg, msg, count, opts)\n    else\n      Gettext.dgettext(Jirasaur.Gettext, \"errors\", msg, opts)\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null]},{"name":"web/views/error_view.ex","source":"defmodule Jirasaur.ErrorView do\n  use Jirasaur.Web, :view\n\n  def render(\"404.html\", _assigns) do\n    \"Page not found\"\n  end\n\n  def render(\"500.html\", _assigns) do\n    \"Internal server error\"\n  end\n\n  # In case no render clause matches or no\n  # template is found, let's render it as 500\n  def template_not_found(_template, assigns) do\n    render \"500.html\", assigns\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null]},{"name":"web/views/layout_view.ex","source":"defmodule Jirasaur.LayoutView do\n  use Jirasaur.Web, :view\nend","coverage":[null,null,null]},{"name":"web/views/page_view.ex","source":"defmodule Jirasaur.PageView do\n  use Jirasaur.Web, :view\nend","coverage":[null,null,null]},{"name":"web/views/user_view.ex","source":"defmodule Jirasaur.UserView do\n  use Jirasaur.Web, :view\nend","coverage":[null,null,null]},{"name":"web/web.ex","source":"defmodule Jirasaur.Web do\n  @moduledoc \"\"\"\n  A module that keeps using definitions for controllers,\n  views and so on.\n\n  This can be used in your application as:\n\n      use Jirasaur.Web, :controller\n      use Jirasaur.Web, :view\n\n  The definitions below will be executed for every view,\n  controller, etc, so keep them short and clean, focused\n  on imports, uses and aliases.\n\n  Do NOT define functions inside the quoted expressions\n  below.\n  \"\"\"\n\n  def model do\n    quote do\n      use Ecto.Schema\n\n      import Ecto\n      import Ecto.Changeset\n      import Ecto.Query\n    end\n  end\n\n  def controller do\n    quote do\n      use Phoenix.Controller\n\n      alias Jirasaur.Repo\n      import Ecto\n      import Ecto.Query\n\n      import Jirasaur.Router.Helpers\n      import Jirasaur.Gettext\n    end\n  end\n\n  def view do\n    quote do\n      use Phoenix.View, root: \"web/templates\"\n\n      # Import convenience functions from controllers\n      import Phoenix.Controller, only: [get_csrf_token: 0, get_flash: 2, view_module: 1]\n\n      # Use all HTML functionality (forms, tags, etc)\n      use Phoenix.HTML\n\n      import Jirasaur.Router.Helpers\n      import Jirasaur.ErrorHelpers\n      import Jirasaur.Gettext\n    end\n  end\n\n  def router do\n    quote do\n      use Phoenix.Router\n    end\n  end\n\n  def channel do\n    quote do\n      use Phoenix.Channel\n\n      alias Jirasaur.Repo\n      import Ecto\n      import Ecto.Query\n      import Jirasaur.Gettext\n    end\n  end\n\n  @doc \"\"\"\n  When used, dispatch to the appropriate controller/view/etc.\n  \"\"\"\n  defmacro __using__(which) when is_atom(which) do\n    apply(__MODULE__, which, [])\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null]}]}