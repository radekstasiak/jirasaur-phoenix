{"source_files":[{"name":"web/controllers/api/v1/report_controller.ex","source":"defmodule Shtask.Api.V1.ReportController do\n\trequire Logger\n  use Shtask.Web, :controller\n  import Shtask.ErrorsHelper\n  alias Shtask.User\n  plug :setup_user\n  plug :setup_task\n  \n  def process_request(conn, _params) do\n  \t\tuser = conn.assigns[:user]\n      task = conn.assigns[:task]\n      #cmd = conn.assigns[:cmd]\n\t\t  #json conn, \"#{user.user_name}:#{cmd}\"\n      json conn, \"user: #{user.user_name},\n                  task: #{task.name},\n                  task type: #{task.task_type.name}\"\n  end\n\n  defp setup_task(conn, params) do\n    if(conn.params[\"text\"] == nil) do\n      show_bad_req(conn)\n    else\n      Shtask.ReportHelper.process_cmd(conn, params)\n    end\n  end\n\n  defp setup_user(conn, _params) do\n  \t\n    if(conn.params[\"user_id\"] != nil) do\n      user_id = String.downcase(conn.params[\"user_id\"])\n    \tuser = Shtask.Repo.get_by(Shtask.User, user_id: user_id)\n    \tif (user == nil) do\n    \t changeset = User.changeset(%User{}, conn.params)\n    \t case Shtask.Repo.insert(changeset) do\n        {:ok, inserted_user} ->\n          user = inserted_user\n          assign(conn, :user, user) \n        {:error, _changeset} ->\n          show_bad_req(conn)\n       end\n   \t  else \n   \t   assign(conn, :user, user)\n    \tend\n    else\n      show_bad_req(conn)\n    end\n  end\n\n\n  \n #TO-DO case insesitivity, user creation\nend","coverage":[null,null,null,null,null,null,null,null,null,17,17,null,null,17,17,17,null,null,null,21,1,null,20,null,null,null,null,null,22,21,21,21,17,17,null,17,17,null,0,null,null,4,null,null,1,null,null,null,null,null,null,null]},{"name":"web/controllers/page_controller.ex","source":"defmodule Shtask.PageController do\n  use Shtask.Web, :controller\n\n  def index(conn, _params) do\n    render conn, \"index.html\"\n  end\nend","coverage":[null,null,null,null,1,null,null]},{"name":"web/helpers/errors_helper.ex","source":"defmodule Shtask.ErrorsHelper do\n  \n  def show_bad_req(conn,assoc \\\\ []) do\n  msg = assoc[:msg] || :bad_request\n   conn\n   |> Plug.Conn.put_status(:bad_request)\n   |> Phoenix.Controller.render(Shtask.ErrorView, \"error.json\", code: msg)\n   |> Plug.Conn.halt()\n  end\n\nend","coverage":[null,null,null,5,null,null,null,5,null,null,null]},{"name":"web/helpers/report_helper.ex","source":"defmodule Shtask.ReportHelper do\n\timport Shtask.ErrorsHelper\n\timport Ecto.Query, only: [from: 2]\n\tuse Timex\n\talias Shtask.Task\n\talias Shtask.TaskStatus\n\talias Shtask.TaskType\n\talias Shtask.UserTask\n\talias Shtask.Repo\n\t\n\tdef send(conn) do\n\t\tconn\n\tend\n\n\tdef process_cmd(conn, _opts) do\n\t\tcmd = String.split(conn.params[\"text\"])\n\t\tcmd_length = Kernel.length(cmd)\n\n\t\tcond do\n\t\t\tcmd_length == 1 ->\n\t\t \t process_task(\n\t\t \t \tconn,\n\t\t \t \ttask_name: Enum.at(cmd, 0)\n\t\t \t \t)\n\t\t\tcmd_length == 2 ->\n\t\t\t process_task(\n\t\t\t \tconn,\n\t\t\t \ttask_name: Enum.at(cmd, 0), \n\t\t\t \tstarted: Enum.at(cmd,1)\n\t\t\t \t)\n\t\t\tcmd_length == 3 ->\n\t\t\t \tprocess_task(\n\t\t\t \tconn, \n\t\t\t \ttask_name: Enum.at(cmd, 0), \n\t\t\t \tstarted: Enum.at(cmd,1),\n\t\t\t \tfinished: Enum.at(cmd,2),\n\t\t\t \t)\n\t\t\ttrue ->\n\t\t\t show_bad_req(conn)\n\t\tend\n\tend\n\n\tdefp process_task(conn,assoc \\\\ []) do\n\t\tuser = conn.assigns[:user]\n\t\ttask_name = String.downcase(assoc[:task_name])\n\t\tif(assoc[:started] != nil) do\n\t\t   task_started = convertTimeToDateTime(assoc[:started])\n\t\t   current_task_finished = convertTimeToDateTime(assoc[:started])\n\t\tend\n\n\t\tif(task_started == nil) do\n\t\t  task_started = Timex.now\n\t\t  current_task_finished = Timex.now\n\t\tend\n\t\tif(assoc[:finished] != nil) do\n\t\t   task_finished = convertTimeToDateTime(assoc[:finished])\n\t\tend\n\n\t\tif(task_finished == nil) do\n\t\t  task_finished = \"\"\n\t\tend\n\t\t\n\t\ttask = get_task(conn,task_name)\n\t\ttask = Task.preload(task.id)\n\t\tconn = Plug.Conn.assign(conn, :task, task)\n\n\t\tmost_recent = get_current_user_task(user.id)\n\t\tcond do\n\t\t\ttask.name == \"off\" and most_recent == nil  ->\n\t\t\t\tshow_bad_req(conn, msg: \"you have no reports today\")\n\t\t\ttask.name == \"morning\" and most_recent != nil ->\n\t\t\t\tshow_bad_req(conn, msg: \"already signed in\")\n\t\t\ttrue ->\n\t\t\t\tif(most_recent != nil) do\n\t\t\t\t\tupdate_current_task(conn,most_recent, current_task_finished)\t\n\t\t\t\tend\n\n\t\t\t\tif(task.name != \"off\") do \n\t\t\t\t\tnew_user_task = insert_user_task(conn, task.id, user.id, task_started, task_finished)\n\t\t\t\t\tconn = Plug.Conn.assign(conn, :user_task, new_user_task)\n\t\t\t\tend\n\t\t\t\tsend(conn)\n\t\tend\n\tend\n\n\tdefp convertTimeToDateTime(time) do\n\t\t[hour, minute] = String.split time, \":\"\n\t\thourInteger = Integer.parse(hour)\n\t\tminuteInteger = Integer.parse(minute)\n\t\ttoday = Timex.now\n\t\tdateTime = %DateTime{year: today.year, month: today.month, day: today.day, hour: elem(hourInteger,0), minute: elem(minuteInteger,0), second: 0, zone_abbr: \"UTC\", time_zone: \"Europe/London\", utc_offset: 0, std_offset: 0}\n\n\tend\n\n\tdefp update_current_task(conn,user_task, finished) do\n\t\tparams = %{task_id: user_task.task_id, \n\t\t\t\t   user_id: user_task.user_id,\n\t\t\t\t   started: user_task.started,\n\t\t\t\t   finished: finished}\n\t\tchangeset = UserTask.changeset(user_task, params)\n\n  \t\tcase Repo.update(changeset) do\n  \t\t {:ok, inserted_user_task} ->\n\t\t\tinserted_user_task\t\n    \t {:error, changeset} ->\n      \t\tshow_bad_req(conn)\n  end\n\t\t\n\tend\n\n\tdefp insert_user_task(conn, task_id, user_id,started, finished) do\n\t\tchangeset = UserTask.changeset(%UserTask{},%{task_id: task_id,\n\t\t\t\t\tuser_id: user_id,\n\t\t\t\t\tstarted: started,\n\t\t\t\t\tfinished: finished,\n\t\t\t\t\t})\n\t\tcase Shtask.Repo.insert(changeset) do\n\t\t\t{:ok, inserted_task} ->\n\t\t\t\tinserted_task\n\t\t\t{:error, _inserted_task_type} ->\n\t\t\t\tshow_bad_req(conn)\n\t\tend\n\tend\n\n\n\tdef get_current_user_task(user_id) do\n\t\tdate = Timex.now\n\t\tquery = Ecto.Query.from(t in UserTask,\n\t\t where: t.started >= ^Timex.beginning_of_day(date),\n\t\t where: t.user_id == ^user_id,\n  \t\t order_by: [desc: t.started],\n  \t\t limit: 1)\n\t\tmost_recent = Repo.one(query)\n\tend\n\n\tdefp get_task(conn,task_name) do\n\t\tShtask.Repo.get_by(Task, name: task_name) ||\n\t\t\t\tinsert_task(conn,task_name)\n\tend\n\n\tdefp insert_task(conn, task_name) do\n\t\ttask_type_name = get_task_type(task_name)\n\t\ttask_type = Shtask.Repo.get_by(TaskType, name: task_type_name) || \n\t\t\t\t\tinsert_new_task_type(conn,task_type_name)\n\t\ttask_status = get_task_status(conn)\n\t\tchangeset = Task.changeset(%Task{},%{name: task_name,\n\t\t\t\t\ttask_type_id: task_type.id,\n\t\t\t\t\ttask_status_id: task_status.id\n\t\t\t\t\t})\n\t\tcase Shtask.Repo.insert(changeset) do\n\t\t\t{:ok, inserted_task} ->\n\t\t\t\tinserted_task\n\t\t\t{:error, _inserted_task_type} ->\n\t\t\t\tshow_bad_req(conn)\n\t\tend\n\tend\n\n\tdefp get_task_type(task_name) do \n\t\ttask_type_name = cond do\n\t\t\ttask_name == \"private\" ->\n\t\t\t \"private\" \n\t\t\ttask_name == \"lunch\" ->\n\t\t\t \"private\"\n\t\t\tRegex.match?((~r/[A-Za-z0-9]*[-][0-9]*/),task_name) ->\n\t\t\t  \"task\"\n\t\t\ttask_name == \"meeting\" ->\n\t\t\t  \"meeting\"\n\t\t\t task_name == \"standup\" ->\n\t\t\t  \"meeting\"\t\n\t\t\ttrue ->\n\t\t\t  \"support\"\n\t\tend\n\tend\n\n\tdefp insert_new_task_type(conn,task_type_name) do\n\t\tchangeset = TaskType.changeset(%TaskType{},%{name: task_type_name})\n\t\tcase Shtask.Repo.insert(changeset) do\n\t\t\t{:ok, inserted_task_type} ->\n\t\t\t\tinserted_task_type\n\t\t\t{:error, _inserted_task_type} ->\n\t\t\t\tshow_bad_req(conn)\n\t\tend\n\n\tend\n\n\tdefp get_task_status(conn) do \n\t\ttask_status_name = \"in progress\"\n\t\tShtask.Repo.get_by(TaskStatus, name: task_status_name) || \n\t\t\t\t\tinsert_new_task_status(conn,task_status_name)\n\tend\n\n\tdefp insert_new_task_status(conn,task_status_name) do\n\t\tchangeset = TaskStatus.changeset(%TaskStatus{},%{name: task_status_name})\n\t\tcase Shtask.Repo.insert(changeset) do\n\t\t\t{:ok, inserted_task_status} ->\n\t\t\t\tinserted_task_status\n\t\t\t{:error, _inserted_task_type} ->\n\t\t\t\tshow_bad_req(conn)\n\t\tend\n\n\tend\n\n\n\n\n\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,17,null,null,null,20,20,null,20,null,17,null,null,null,3,1,null,null,null,null,2,1,null,null,null,null,null,null,1,null,null,null,null,19,19,19,2,2,null,null,19,17,17,null,19,1,null,null,19,18,null,null,19,19,19,null,19,19,19,1,18,1,null,17,3,null,null,17,16,16,null,17,null,null,null,null,5,5,5,5,5,null,null,null,null,3,3,3,null,3,null,3,null,3,null,0,null,null,null,null,null,16,null,null,null,null,16,null,16,null,0,null,null,null,null,null,21,21,null,null,null,null,21,null,null,null,19,15,null,null,null,15,15,13,15,15,15,15,null,15,null,15,null,0,null,null,null,null,15,null,null,14,null,14,null,10,null,9,null,null,null,null,null,null,null,13,13,null,13,null,0,null,null,null,null,null,15,15,14,null,null,null,14,14,null,14,null,0,null,null,null,null,null,null,null,null,null]},{"name":"web/models/task.ex","source":"defmodule Shtask.Task do\n  use Shtask.Web, :model\n  import Ecto.Query\n  schema \"tasks\" do\n    field :name, :string\n    belongs_to :task_type, Shtask.TaskType\n    belongs_to :task_status, Shtask.TaskStatus\n    has_many :user_tasks, Shtask.UserTask\n    many_to_many :users, Shtask.User, join_through: Shtask.UserTask\n    timestamps()\n  end\n\n  def preload(id) do\n    task = Shtask.Task |> Shtask.Repo.get(id) |> Shtask.Repo.preload([:users])|> Shtask.Repo.preload([:task_type]) |> Shtask.Repo.preload([:task_status]) |> Shtask.Repo.preload([:user_tasks])\n  end\n  @doc \"\"\"\n  Builds a changeset based on the `struct` and `params`.\n  \"\"\"\n  def changeset(struct, params \\\\ %{}) do\n    #IO.puts(\"#{params}\")\n    struct\n    |> cast(params, [:name,:task_type_id,:task_status_id])\n    |> downcase_value\n    |> validate_required([:name,:task_type_id,:task_status_id])\n    |> unique_constraint(:name)\n    |> foreign_key_constraint(:task_type_id)\n    |> foreign_key_constraint(:task_status_id)\n  end\n\n\n  def downcase_value(changeset) do\n      \n      update_change(changeset, :name, &String.downcase/1)\n  end\n\nend","coverage":[null,null,null,36,null,null,null,null,null,null,null,null,null,23,null,null,null,null,null,null,null,null,null,null,null,null,38,null,null,null,null,null,38,null,null,null]},{"name":"web/models/task_status.ex","source":"defmodule Shtask.TaskStatus do\n  use Shtask.Web, :model\n\n  schema \"taskstatuses\" do\n    field :name, :string\n    has_many :tasks, Shtask.Task\n    timestamps()\n  end\n\n  def preload(id) do\n    user = Shtask.TaskStatus |> Shtask.Repo.get(id)|> Shtask.Repo.preload([:tasks])\n  end\n  @doc \"\"\"\n  Builds a changeset based on the `struct` and `params`.\n  \"\"\"\n  def changeset(struct, params \\\\ %{}) do\n    struct\n    |> cast(params, [:name])\n    |> downcase_value\n    |> validate_required([:name])\n    |> unique_constraint(:name)\n  end\n\n  def downcase_value(changeset) do\n      update_change(changeset, :name, &String.downcase/1)\n  end\nend","coverage":[null,null,null,25,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,38,null,null,null,38,null,null]},{"name":"web/models/task_type.ex","source":"defmodule Shtask.TaskType do\n  use Shtask.Web, :model\n\n  schema \"tasktypes\" do\n    field :name, :string\n    has_many :tasks, Shtask.Task\n    timestamps()\n  end\n\n  def preload(id) do\n    user = Shtask.TaskType |> Shtask.Repo.get(id)|> Shtask.Repo.preload([:tasks])\n  end\n  @doc \"\"\"\n  Builds a changeset based on the `struct` and `params`.\n  \"\"\"\n  def changeset(struct, params \\\\ %{}) do\n    struct\n    |> cast(params, [:name])\n    |> downcase_value\n    |> validate_required([:name])\n    |> unique_constraint(:name)\n  end\n\n  def downcase_value(changeset) do\n      update_change(changeset, :name, &String.downcase/1)\n  end\nend","coverage":[null,null,null,41,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,38,null,null,null,38,null,null]},{"name":"web/models/user.ex","source":"defmodule Shtask.User do\n  use Shtask.Web, :model\n\n  schema \"users\" do\n    field :user_id, :string\n    field :user_name, :string\n    field :team_id, :string\n    field :team_domain, :string\n    has_many :user_tasks, Shtask.UserTask\n    many_to_many :tasks, Shtask.Task, join_through: Shtask.UserTask\n    timestamps()\n  end\n\n  def preload(id) do\n    user = Shtask.User |> Shtask.Repo.get(id)|> Shtask.Repo.preload([:tasks]) |> Shtask.Repo.preload([:user_tasks])\n  end\n\n  @doc \"\"\"\n  Builds a changeset based on the `struct` and `params`.\n  \"\"\"\n  def changeset(struct, params \\\\ %{}) do\n    struct\n    |> cast(params, [:user_id, :user_name, :team_id, :team_domain])\n    |> downcase_value\n    |> validate_required([:user_id, :user_name, :team_id, :team_domain])\n    |> unique_constraint(:user_id)\n  end\n\n  def downcase_value(changeset) do\n      update_change(changeset, :user_id, &String.downcase/1)\n  end\nend","coverage":[null,null,null,3,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,48,null,null,null,48,null,null]},{"name":"web/models/user_task.ex","source":"defmodule Shtask.UserTask do\n  use Shtask.Web, :model\n\n  schema \"usertasks\" do\n    field :started, Timex.Ecto.DateTime\n    field :finished, Timex.Ecto.DateTime\n    belongs_to :task, Shtask.Task\n    belongs_to :user, Shtask.User\n    timestamps()\n  end\n\n  def preload(id) do\n    user_task = Shtask.UserTask |> Shtask.Repo.get(id)|> Shtask.Repo.preload([:task]) |> Shtask.Repo.preload([:user])\n  end\n  @doc \"\"\"\n  Builds a changeset based on the `struct` and `params`.\n  \"\"\"\n  def changeset(struct, params \\\\ %{}) do\n    struct\n    |> cast(params, [:started, :finished,:task_id,:user_id])\n    |> validate_required([:started,:task_id,:user_id])\n    |> foreign_key_constraint(:task_id)\n    |> foreign_key_constraint(:user_id)\n  end\nend","coverage":[null,null,null,77,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,45,null,null]},{"name":"web/plug/authenticate_plug.ex","source":"defmodule Shtask.Plug.Authenticate do\n  @behaviour Plug\n  import Plug.Conn\n  import Phoenix.Controller, only: [render: 4]\n\n  def init(opts), do: opts\n\n  def call(conn, _opts) do\n    slack_token = System.get_env(\"SLACK_TOKEN\")\n    if (slack_token ==nil || slack_token != conn.params[\"token\"]) do  \n      conn\n      |> put_status(:unauthorized)\n      |> render(Shtask.ErrorView, \"error.json\", code: :unauthorized)\n      |> halt()\n    else\n      conn\n    end\n  end\nend","coverage":[null,null,null,null,null,0,null,null,23,23,null,null,null,1,null,22,null,null,null]}]}
